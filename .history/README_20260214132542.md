# kitchensink-testing

Reusable testing infrastructure for property, mutation, and hardening workflows.

## Feature matrix

| Surface | Purpose | Status |
| --- | --- | --- |
| `generators` | Reusable property-based input strategies | Available |
| `law::algebraic` | Algebraic law assertions | Available |
| `law::invariants` | Range/monotonicity/assert-equality helpers | Available |
| `law::stateful` | Stateful transition/idempotence assertions | Available |
| `law::serialization` | JSON/bincode roundtrip + determinism checks | Available |
| `mutation` | Resumable `cargo pbt` mutation orchestration | Available |
| Local fuzz harness support | Optional consumer-owned `fuzz/` integration | Supported |

## Install

```toml
[dev-dependencies]
kitchensink-testing = "0.2"
```

## What this crate gives you

- generators in `rust_pbt::generators::*`
- invariant helpers in `rust_pbt::law::*`
- optional mutation runtime via `cargo-pbt` (`mutation` feature)
- deterministic serialization assertions

## Minimal integration

Add test surface files in your consumer crate and import `rust_pbt::prelude::*`.

```toml
[dev-dependencies]
kitchensink-testing = { package = "kitchensink-testing", path = "../rust-pbt", default-features = false, features = ["core", "serialization", "mutation"] }
```

Use `cargo pbt` commands for mutation:

```bash
cargo pbt mutate run --project .
cargo pbt mutate status <run-id>
cargo pbt mutate report <run-id> --format json
cargo pbt mutate list <run-id> --json
cargo pbt mutate inspect <run-id> <mutant-id> --log
```

Run-state is persisted at:

- `.kitchensink-testing/mutation/runs/<run-id>/events.jsonl`

For a copy-paste integration playbook, see `docs/integration.md`.
